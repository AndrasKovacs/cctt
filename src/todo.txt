
Strict inductives:

syntax:

--------------------------------------------------------------------------------



data D (x1 : A1)(x2 : A2) ... (xn : An) :=
    c1 (x1 : A1)(x2 : A2) ... (xn : An)
   |c2 (x1 : A1)(x2 : A2) ... (xn : An)
   |...
   |cn (x1 : A1)(x2 : A2) ... (xn : An);


elim x [c1 x y z. t1; c2 x y z. t2; ... ]                 -- x, y, z bind all induction hypotheses



--------------------------------------------------------------------------------


- params are not stored
- constructors are checkable only and always saturated
- no shadowing in constructors

syntactic con signatures: right-nested telescope

   ConSig = CSNil | CSInd Name ConSig | CSExt Name Ty Con | CSHInd Name Ty Con

semantics
- tycon is identified by level
- datacon is identified by two levels: the type level and the level of the con inside the
  type.

   data Val
     VITyCon Lvl [Val]
     VIDCon Lvl Lvl IDSpine               -- IDCon could be packed to 1 word

  data IDSpine = IDNil | IDInd Val IDSpine | IDHInd Val IDSpine | IDExt Val IDSpine

  data Ne
     NIElim Val [(Sub, Env, [Name], Tm)]      -- basically an evaluation closure for each method


  -- eval an elim:
  --   if scrutinee canonical, eval the branch
  --   otherwise eval methods to list of closures
    (this is the optimized version, for simplicity we could just create the closures first
     and pass it the semantic elim next. Slightly less efficient but who cares)


coe r r' (Ty P) (DCon args)
  -- inductive arg: recursive coe
  -- ext arg: coe over params (every external arg is a type family indexed by Par)                    List (A : U) := nil | cons (A * A * A) Rec


-- Simple case: closed HITs
-- coe does nothing
-- hcom is formal


--------------------------------------------------------------------------------

Testing:
  - hcom glue
  - coe glue

Feature:
- 1. all Kan computation rules
- 2. strict inductives
- 3. HITs

Convenience:
- print elab cof environment on errors
- sprinkle more source positions in the parser.
- improve system compatibility error messages
  - improve system error positions
- sugar for cof disjunction and âˆ€ in systems.

- sugar for iterated projection:
  (print right-nested projection as number?
    x.1  ~ x.1
    x.2  ~ x.2.1
    x.3  ~ x.2.2.1
    x.4  ~ x.2.2.2.1
    but what about the rightmost field? Should we just use a dummy ending field?


Performance:

- unbox VSys types
- coe Glue: unfold the hcom fiber
- switch to ByteString megaparsec input
