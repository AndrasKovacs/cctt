
{-
Sugar:
- When checking case with variable scrutinee, infer motive
- When checking case with non-variable scrutinee, infer non-dependent motive
-}

--------------------------------------------------------------------------------

data Foo := R | G | B;
foo : Foo := G;

data â„• := zero | suc â„•;

czero (n : â„•) : â„• :=
  case n (_. â„•) [
    zero. zero;
    suc n. czero n];

add : â„• â†’ â„• â†’ â„• := Î»[
  zero. Î» x. x;
  suc n. Î» x. suc (add n x)];

five := suc (suc (suc (suc (suc zero))));

ten := add five five;

mul (n m : â„•) : â„• :=
  case n (_. â„•) [
    zero. zero;
    suc n. add m (mul n m)];

n100 := mul ten ten;

--------------------------------------------------------------------------------

data List (A : U) := nil | cons A (List A);

map (A B : U) (f : A â†’ B)(as : List A) : List B :=
  case as (_. List B) [
    nil. nil;
    cons a as. cons (f a) (map A B f as)];

list1 : List â„• := cons ten (cons ten (cons ten nil));
list2 := map â„• â„• (Î» _. zero) list1;

--------------------------------------------------------------------------------

data Bad := mkBad (Bad â†’ Bad);

data ğŸ™ := tt;

data ğŸ˜ :=;

ğŸ˜-elim (A : U)(p : ğŸ˜) : A := case p (_. A) [];

data W (A : U)(B : A â†’ U) := sup (a : A)(f : B a â†’ W A B);

data O := ozero | osuc O | olim (â„• â†’ O);

fromâ„• (n : â„•) : O := case n (_. O) [
  zero. ozero;
  suc n. osuc (fromâ„• n)];

oten := fromâ„• ten;

Ï‰ := olim fromâ„•;

iter (A : U)(n : â„•) (f : A â†’ A) (a : A) : A := case n (_. A) [
  zero. a;
  suc n. f (iter A n f a)];

-- fast-growing function
fgf (o : O) (n : â„•) : â„• := case o (_. â„•) [
  ozero . suc n;
  osuc o. iter â„• n (fgf o) n;
  olim f. fgf (f n) n];

fÏ‰2 := fgf Ï‰ (suc (suc zero));

--------------------------------------------------------------------------------

data Vec (A : U) (n : â„•) :=
    vnil (n = zero)
  | vcons (m : â„•) (n = suc m) A (Vec A m) ;

vmap (A B : U)(n : â„•)(f : A â†’ B)(as : Vec A n) : Vec B n :=
  case as (_. Vec B n) [
    vnil p. vnil p;
    vcons m p a as. vcons m p (f a) (vmap A B m f as)];

v1 : Vec â„• (suc (suc zero)) :=
  vcons (suc zero) refl ten (vcons zero refl ten (vnil refl));

v2 := vmap â„• â„• (suc (suc zero)) (add ten) v1;


-- Recursive identities
--------------------------------------------------------------------------------

data RecId :=
    Base
  | Path (Base = Base);

recid1 := Path reflâ»Â¹;

--------------------------------------------------------------------------------

data Sum (A B : U) := Left A | Right B;
Dec (A : U) := Sum A (A â†’ ğŸ˜);

the (A : U)(x : A) := x;

â„•-Elim : (P : â„• â†’ U)(pz : P zero)(ps : (n : â„•) â†’ P n â†’ P (suc n))(n : â„•) â†’ P n :=
  Î» P pz ps. Î»[
    zero. pz;
    suc n. ps n (â„•-Elim P pz ps n)];

not (A : U) := A â†’ ğŸ˜;

zeroNotSuc (n : â„•)(p : zero = suc n) : ğŸ˜ :=
  let f : â„• â†’ U := Î»[zero. ğŸ™; suc _. ğŸ˜];
  coe 0 1 (ap f p) tt;

pred : â„• â†’ â„• := Î»[zero. zero; suc n. n];

â„•-Dec : (n m : â„•) â†’ Dec (n = m) :=
  Î» [zero.  Î» [zero. Left refl;
               suc m. Right (zeroNotSuc m)];
     suc n. Î» [zero. Right (Î» p. zeroNotSuc n pâ»Â¹);
               suc m. case (â„•-Dec n m) (_. Dec (suc n = suc m)) [
	          Left  p. Left (Î» i. suc (p i));
		  Right p. Right (Î» q. p (ap pred q))]]];

test := â„•-Dec (suc zero) zero;
