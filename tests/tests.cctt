
{-

Sugar & stuff.

- Add Split as primitive presyntax and core syntax
  - Evaluate split directly to the semantic (Î» x. case x ...) closure
  - Split is checkable

- Allow omitted return type in case
  - infer constant return type from first branch


-}


--------------------------------------------------------------------------------

data Foo := R | G | B;
foo : Foo := G;

data â„• := zero | suc â„•;

czero (n : â„•) : â„• :=
  case n (_. â„•) [
    zero. zero;
    suc n. czero n];

add (n : â„•) (m : â„•) : â„• :=
  case n (_. â„•) [
    zero. m;
    suc n. suc (add n m)];

five := suc (suc (suc (suc (suc zero))));

ten := add five five;

mul (n m : â„•) : â„• :=
  case n (_. â„•) [
    zero. zero;
    suc n. add m (mul n m)];

n100 := mul ten ten;

--------------------------------------------------------------------------------

data List (A : U) := nil | cons A (List A);

map (A B : U) (f : A â†’ B)(as : List A) : List B :=
  case as (_. List B) [
    nil. nil;
    cons a as. cons (f a) (map A B f as)];

list1 : List â„• := cons ten (cons ten (cons ten nil));
list2 := map â„• â„• (Î» _. zero) list1;

--------------------------------------------------------------------------------

data Bad := mkBad (Bad â†’ Bad);

data ğŸ™ := tt;

data ğŸ˜ :=;

ğŸ˜-elim (A : U)(p : ğŸ˜) : A := case p (_. A) [];

data W (A : U)(B : A â†’ U) := sup (a : A)(f : B a â†’ W A B);

data O := ozero | osuc O | olim (â„• â†’ O);

fromâ„• (n : â„•) : O := case n (_. O) [
  zero. ozero;
  suc n. osuc (fromâ„• n)];

oten := fromâ„• ten;

Ï‰ := olim fromâ„•;

iter (A : U)(n : â„•) (f : A â†’ A) (a : A) : A := case n (_. A) [
  zero. a;
  suc n. f (iter A n f a)];

-- fast-growing function
fgf (o : O) (n : â„•) : â„• := case o (_. â„•) [
  ozero . suc n;
  osuc o. iter â„• n (fgf o) n;
  olim f. fgf (f n) n];

fÏ‰2 := fgf Ï‰ (suc (suc zero));

--------------------------------------------------------------------------------

data Vec (A : U) (n : â„•) :=
    vnil (n = zero)
  | vcons (m : â„•) (n = suc m) A (Vec A m) ;

vmap (A B : U)(n : â„•)(f : A â†’ B)(as : Vec A n) : Vec B n :=
  case as (_. Vec B n) [
    vnil p. vnil p;
    vcons m p a as. vcons m p (f a) (vmap A B m f as)];

v1 : Vec â„• (suc (suc zero)) :=
  vcons (suc zero) refl ten (vcons zero refl ten (vnil refl));

v2 := vmap â„• â„• (suc (suc zero)) (add ten) v1;


-- Recursive identities
--------------------------------------------------------------------------------

data RecId :=
    Base
  | Path (Base = Base);

recid1 := Path reflâ»Â¹;
