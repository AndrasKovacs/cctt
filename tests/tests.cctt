
{-
Sugar:
- When checking case with variable scrutinee, infer motive
- When checking case with non-variable scrutinee, infer non-dependent motive
-}

--------------------------------------------------------------------------------

data Foo := R | G | B;
foo : Foo := G;

data ℕ := zero | suc ℕ;

czero (n : ℕ) : ℕ :=
  case n (_. ℕ) [
    zero. zero;
    suc n. czero n];

add : ℕ → ℕ → ℕ := λ[
  zero. λ x. x;
  suc n. λ x. suc (add n x)];

five := suc (suc (suc (suc (suc zero))));

ten := add five five;

mul (n m : ℕ) : ℕ :=
  case n (_. ℕ) [
    zero. zero;
    suc n. add m (mul n m)];

n100 := mul ten ten;

--------------------------------------------------------------------------------

data List (A : U) := nil | cons A (List A);

map (A B : U) (f : A → B)(as : List A) : List B :=
  case as (_. List B) [
    nil. nil;
    cons a as. cons (f a) (map A B f as)];

list1 : List ℕ := cons ten (cons ten (cons ten nil));
list2 := map ℕ ℕ (λ _. zero) list1;

--------------------------------------------------------------------------------

data Bad := mkBad (Bad → Bad);

data 𝟙 := tt;

data 𝟘 :=;

𝟘-elim (A : U)(p : 𝟘) : A := case p (_. A) [];

data W (A : U)(B : A → U) := sup (a : A)(f : B a → W A B);

data O := ozero | osuc O | olim (ℕ → O);

fromℕ (n : ℕ) : O := case n (_. O) [
  zero. ozero;
  suc n. osuc (fromℕ n)];

oten := fromℕ ten;

ω := olim fromℕ;

iter (A : U)(n : ℕ) (f : A → A) (a : A) : A := case n (_. A) [
  zero. a;
  suc n. f (iter A n f a)];

-- fast-growing function
fgf (o : O) (n : ℕ) : ℕ := case o (_. ℕ) [
  ozero . suc n;
  osuc o. iter ℕ n (fgf o) n;
  olim f. fgf (f n) n];

fω2 := fgf ω (suc (suc zero));

--------------------------------------------------------------------------------

data Vec (A : U) (n : ℕ) :=
    vnil (n = zero)
  | vcons (m : ℕ) (n = suc m) A (Vec A m) ;

vmap (A B : U)(n : ℕ)(f : A → B)(as : Vec A n) : Vec B n :=
  case as (_. Vec B n) [
    vnil p. vnil p;
    vcons m p a as. vcons m p (f a) (vmap A B m f as)];

v1 : Vec ℕ (suc (suc zero)) :=
  vcons (suc zero) refl ten (vcons zero refl ten (vnil refl));

v2 := vmap ℕ ℕ (suc (suc zero)) (add ten) v1;


-- Recursive identities
--------------------------------------------------------------------------------

data RecId :=
    Base
  | Path (Base = Base);

recid1 := Path refl⁻¹;

--------------------------------------------------------------------------------

data Sum (A B : U) := Left A | Right B;
Dec (A : U) := Sum A (A → 𝟘);

the (A : U)(x : A) := x;

ℕ-Elim : (P : ℕ → U)(pz : P zero)(ps : (n : ℕ) → P n → P (suc n))(n : ℕ) → P n :=
  λ P pz ps. λ[
    zero. pz;
    suc n. ps n (ℕ-Elim P pz ps n)];

not (A : U) := A → 𝟘;

zeroNotSuc (n : ℕ)(p : zero = suc n) : 𝟘 :=
  let f : ℕ → U := λ[zero. 𝟙; suc _. 𝟘];
  coe 0 1 (ap f p) tt;

pred : ℕ → ℕ := λ[zero. zero; suc n. n];

ℕ-Dec : (n m : ℕ) → Dec (n = m) :=
  λ [zero.  λ [zero. Left refl;
               suc m. Right (zeroNotSuc m)];
     suc n. λ [zero. Right (λ p. zeroNotSuc n p⁻¹);
               suc m. case (ℕ-Dec n m) (_. Dec (suc n = suc m)) [
	          Left  p. Left (λ i. suc (p i));
		  Right p. Right (λ q. p (ap pred q))]]];

test := ℕ-Dec (suc zero) zero;
