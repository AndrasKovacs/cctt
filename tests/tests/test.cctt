isEquiv (A B : U)(f : A → B) : U :=
    (g    : B → A)
  × (linv : (x : A) → x = g (f x))
  × (rinv : (x : B) → f (g x) = x)
  × (coh  : (x : A) → refl ={i. f (linv x i) = f x} (rinv (f x)));

isIso (A B : U)(f : A → B) : U :=
    (g    : B → A)
  × (linv : (x : A) → x = g (f x))
  × (rinv : (x : B) → f (g x) = x);

isSection (A B : U)(f : A → B) : U := (g : B → A) × ((x : A) → x = g (f x));

isLogEquiv (A B : U)(f : A → B) : U := (B → A);

equiv (A B : U) : U :=
  (f : A → B) × isEquiv A B f;

idEquiv (A : U) : equiv A A :=
  (λ x. x, λ x. x, λ x _. x, λ x _. x, λ x _ _. x);

isProp (A : U) : U := (a b : A) → a = b;

isPropIsEquiv (A B : U) (f : A → B) : isProp (isEquiv A B f) := ?_;

higher inductive S1 :=
    base1
  | loop1 (i : I) [i=0. base1; i=1. base1];

connection-both (A : U)(p : I → A)(rhs : A)(q : p 1 = rhs) (i j : I) : A :=
  let pface (m k : I) : A := hcom 1 m [k=0 _. p 1; k=1. p] (p 1);
  let qface (m k : I) : A := hcom 0 m [k=0 _. p 1; k=1. q] (p 1);
  hcom 0 1 [
    i=0. pface j;
    i=1. qface j;
    j=0. pface i;
    j=1. qface i]
    (p 1);

rotLoop : (a : S1) → a = a := λ[
  base1.   λ i. loop1 i;
  loop1 i. λ j. connection-both S1 (λ i. loop1 i) base1 (λ i. loop1 i) i j
];

rot : S1 → S1 → S1 := λ[
  base1. λ y. y;
  loop1 i. λ y. rotLoop y i
];

isPropFamS1 (P : S1 → U)(pP : (x : S1) → isProp (P x)) (b0 : P base1) : b0 ={i. P (loop1 i)} b0 :=
  λ i. pP (loop1 i) (coe 0 i (K1. P (loop1 K1)) b0)
                    (coe 1 i (K2. P (loop1 K2)) b0) i;

the (A : U) (x : A) := x;

foo (P : S1 → U)(pP : (x : S1) → isProp (P x)) (b0 : P base1)(i : I) : P (loop1 i) :=
       (coe 0 i (K1. P (loop1 K1)) b0);

-- test (i : I) : isSection S1 S1 (λ y. rotLoop y i) :=
--   coe 0 i (j. isSection S1 S1 (λ y. rotLoop y j)) ?_;

test (i : I)(sec : isSection S1 S1 (λ y. rotLoop y 0)) : isSection S1 S1 (λ y. rotLoop y i) :=
  --   coe 0 i (_. S1 → S1) sec.1
  -- , coe 0 i (j. (x : S1) → x = (coe 0 j (_. S1 → S1) sec.1) (rotLoop x j)) sec.2;

  -- coe 0 i (j. isSection S1 S1 (λ y. rotLoop y j)) sec;

  coe 0 i (j. (g : S1 → S1) × ((x : S1) → x = g (rotLoop x j))) sec;



-- (linv : (x : A) → x = g (f x));

{-

isEquiv (A B : U)(f : A → B) : U :=
    (g    : B → A)
  × (linv : (x : A) → x = g (f x))
  × (rinv : (x : B) → f (g x) = x)
  × (coh  : (x : A) → refl ={i. f (linv x i) = f x} (rinv (f x)));

equiv (A B : U) : U :=
  (f : A → B) × isEquiv A B f;

idEquiv (A : U) : equiv A A :=
  (λ x. x, λ x. x, λ x _. x, λ x _. x, λ x _ _. x);

isProp (A : U) : U := (a b : A) → a = b;

isPropIsEquiv (A B : U) (f : A → B) : isProp (isEquiv A B f) := ?_;

higher inductive S1 :=
    base1
  | loop1 (i : I) [i=0. base1; i=1. base1];

connection-both (A : U)(p : I → A)(rhs : A)(q : p 1 = rhs) (i j : I) : A :=
  let pface (m k : I) : A := hcom 1 m [k=0 _. p 1; k=1. p] (p 1);
  let qface (m k : I) : A := hcom 0 m [k=0 _. p 1; k=1. q] (p 1);
  hcom 0 1 [
    i=0. pface j;
    i=1. qface j;
    j=0. pface i;
    j=1. qface i]
    (p 1);

rotLoop : (a : S1) → a = a := λ[
  base1.   λ i. loop1 i;
  loop1 i. λ j. connection-both S1 (λ i. loop1 i) base1 (λ i. loop1 i) i j
];

rot : S1 → S1 → S1 := λ[
  base1. λ y. y;
  loop1 i. λ y. rotLoop y i
];

isPropFamS1 (P : S1 → U)(pP : (x : S1) → isProp (P x)) (b0 : P base1) : b0 ={i. P (loop1 i)} b0 :=
  λ i. pP (loop1 i) (coe 0 i (K1. P (loop1 K1)) b0)
                    (coe 1 i (K2. P (loop1 K2)) b0) i;


-- TODO: NF throws error!
rotIsEquiv : (a : S1) → isEquiv S1 S1 (rot a) := λ[
  base1. (idEquiv S1).2;
  loop1 i. isPropFamS1 (λ x. isEquiv S1 S1 (rot x))
                       (λ x. isPropIsEquiv S1 S1 (rot x))
		       ((idEquiv S1).2) i
];

-}